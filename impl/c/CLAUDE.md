# CLAUDE.md — xmss-jasmin C implementation

Context for Claude Code when working on the C implementation of XMSS/XMSS-MT. All paths below are relative to `impl/c/`.

## Build commands

The `Makefile` wraps CMake for convenience:

```bash
make            # Release build
make test       # Build + run all tests (~2 min)
make test-fast  # Build + run only fast tests (CTest label "fast")
make debug      # Debug build (ASan + UBSan — very slow for crypto tests)
make rv         # RISC-V cross-compile
make clean      # Remove all build directories

# Run a single test binary directly
./build-rel/test/test_params
./build-rel/test/test_xmss   # BDS keygen/sign/verify roundtrip + sequential
./build-rel/test/test_xmss_kat    # KAT cross-validation (advances BDS to idx=512)
./build-rel/test/test_bds    # BDS-specific: bds_k validation, k=2/k=4 roundtrips

# RISC-V execution via QEMU
qemu-riscv64 -L /usr/riscv64-linux-gnu build-rv/test/test_params
qemu-riscv64 -L /usr/riscv64-linux-gnu build-rv/test/test_xmss
```

## CI

GitHub Actions CI:
- **`ci.yml`** (every push/PR): gcc and clang native Release builds with `-Werror`, all 12 tests (~4 min each)
- **`riscv.yml`** (weekly + manual): RISC-V cross-compile + QEMU, fast tests + sign/verify roundtrips (test_xmss, test_xmss_mt)

**Workflow**: run `make test-fast` locally for quick smoke checks, then push to let CI run the full suite across both compilers. Avoid running slow tests (KAT, XMSS-MT boundary crossing) locally unless debugging a specific failure.

Check CI: `gh run list`, `gh run view <id>`, `gh run watch <id> --exit-status`

### CMake options for CI

| Option | Default | Description |
|--------|---------|-------------|
| `XMSS_WERROR` | `OFF` | Promote warnings to errors (`-Werror`) |
| `XMSS_TEST_TIMEOUT_SCALE` | `1` | Multiplier for test timeouts (4 for QEMU) |

## Architecture

### Hash abstraction boundary

`src/hash/xmss_hash.c` is the **sole** file that dispatches to SHA-2 or SHAKE. All algorithm code (`wots.c`, `ltree.c`, `treehash.c`, `bds.c`, `xmss.c`, `xmss_mt.c`) calls only:

```c
xmss_F(), xmss_H(), xmss_H_msg(), xmss_PRF(), xmss_PRF_keygen(), xmss_PRF_idx()
```

declared in `src/hash/hash_iface.h`. Do not add hash backend includes to any other file.

### No malloc

The entire library is allocation-free. All buffers are either stack-local or caller-provided. The largest allocations are:
- `xmss_mt_state`: ~780 KB (caller-managed; holds 2xMAX_D-1 BDS states + WOTS sig cache)
- `xmss_bds_state`: ~34 KB (caller-managed; see `include/xmss/xmss.h`)
- `wots_buf_t`: `XMSS_MAX_WOTS_LEN * XMSS_MAX_N` = 131 x 64 = 8384 bytes (in `wots.c`)
- `treehash_stack_t`: `(XMSS_MAX_H+1) * XMSS_MAX_N` = 21 x 64 = 1344 bytes (in `treehash.c`)

### Key constants (params.h)

```c
XMSS_MAX_N        64   // max hash output bytes (n)
XMSS_MAX_H        20   // max per-tree height (BDS arrays sized by this)
XMSS_MAX_FULL_H   60   // max total tree height across all layers
XMSS_MAX_D        12   // max number of layers (XMSSMT-*_60/12_*)
XMSS_MAX_WOTS_LEN 131  // max WOTS+ chain count (len1+len2 for n=64, w=16)
XMSS_MAX_BDS_K    4    // max BDS retain parameter (must be even, <= tree_height)
```

These must be kept consistent with the OID table in `src/params.c`. If new parameter sets are added, recalculate and update accordingly.

### ADRS (address) structure

`xmss_adrs_t` is 8 x `uint32_t` stored big-endian. Always manipulate via the setters in `src/address.h`. **Never** write to `a.w[]` directly in algorithm code.

`xmss_adrs_set_type()` zeros words 4-7 as required by RFC 8391 section 2.5. This differs from xmss-reference which does not do this.

### SK/PK layout (Errata 7900)

```
SK: OID(4) | idx(idx_bytes) | SK_SEED(n) | SK_PRF(n) | root(n) | SEED(n)
PK: OID(4) | root(n) | SEED(n)
XMSS Sig:    idx(idx_bytes) | r(n) | sig_WOTS(len*n) | auth(tree_height*n)
XMSS-MT Sig: idx(idx_bytes) | r(n) | d x [sig_WOTS(len*n) | auth(tree_height*n)]
```

SK/PK layout is the same for XMSS and XMSS-MT (only idx_bytes differs).
Offset helpers are shared `static inline` functions in `src/sk_offsets.h`, included by both `xmss.c` and `xmss_mt.c`.

### SHA-2 domain separation (RFC 8391 section 5.1)

The SHA-2 hash functions prepend `toByte(D, n)` (n-1 zero bytes then byte D):
- F = 0x00, H = 0x01, H_msg = 0x02, PRF = 0x03, PRF_keygen = 0x04

SHA-2 F and H also XOR inputs with bitmasks generated by PRF calls with `key_and_mask=0,1`. SHAKE does not use bitmasks.

### `xmss_PRF_idx`

A special variant of PRF used only in `xmss_sign` to compute `r = PRF(SK_PRF, toByte(idx, 32))`. The 32-byte input is a raw index encoding, not an ADRS structure. Declared in `hash_iface.h`, implemented in `xmss_hash.c`.

## Jasmin portability rules

These are enforced and must not be broken by any change:

| Rule | What to check |
|------|---------------|
| J1 | No VLAs -- use `XMSS_MAX_*` constants. `-Wvla` will catch violations at compile time. |
| J2 | No function pointers in algorithm code. Dispatch lives only in `xmss_hash.c`. |
| J3 | No `malloc`/`calloc`/`free` anywhere in `src/`. |
| J4 | No recursive functions. All tree algorithms are iterative with explicit stacks. |
| J5 | All loop bounds must be compile-time constants or `params->*` fields. |
| J6 | Secret-dependent branches and memory accesses must be constant-time. Verification uses `ct_memcmp`. Annotate deviations. |
| J7 | ADRS passed by pointer to setters; serialised to `uint8_t[32]` on the stack before passing to hash functions. |
| J8 | One algorithm per `.c` file. |

## Test structure

| Binary | What it tests |
|--------|--------------|
| `test_params` | All 12 XMSS OIDs: n, w, h, len, sig_bytes, pk_bytes, sk_bytes, idx_bytes |
| `test_address` | ADRS serialisation, all setter types, set_type() zeroing |
| `test_hash` | SHA-256, SHA-512 (FIPS 180-4 vectors), SHAKE-128, SHAKE-256 (NIST vectors), incremental API |
| `test_wots` | sign->pkFromSig roundtrip (n=32 and n=64), wrong message detection |
| `test_xmss` | BDS keygen/sign/verify roundtrip (3 param sets); bit-flip and wrong-message rejection; idx increment; sequential signing (20 sigs) |
| `test_xmss_kat` | SHAKE128-fingerprint cross-validation against xmss-reference for 4 XMSS parameter sets: SHA-2/SHAKE × n=32/n=64, h=10 (advances BDS to idx=512 for sig fingerprint) |
| `test_bds` | BDS-specific: bds_k validation (odd/too-large rejected); roundtrip and sequential signing with bds_k=2 and bds_k=4 |
| `test_bds_serial` | BDS serialization: round-trip after keygen, mid-signing, byte-exact, size consistency, multiple param sets, bds_k=2 |
| `test_xmss_mt_params` | All 32 XMSS-MT OIDs: n, w, h, d, tree_height, len, sig_bytes, pk_bytes, sk_bytes, idx_bytes; RFC and internal OID lookup |
| `test_xmss_mt` | XMSS-MT keygen/sign/verify roundtrip; bit-flip and wrong-message rejection; sequential signing (5 sigs); tree boundary crossing (1024+ sigs) |
| `test_utils_internal` | ct_memcmp, ull_to_bytes, bytes_to_ull, xmss_memzero, xmss_PRF_idx, key exhaustion |

`test_utils.h` provides a deterministic RNG (`test_randombytes`) seeded with `test_rng_reset()` for reproducible test runs.

## Dependencies

None at runtime. Build requires CMake >= 3.16 and a C99 compiler.

| `test_xmss_mt_kat` | XMSS-MT KAT: cross-validation against xmss-reference for 4 XMSS-MT parameter sets: SHA-2/SHAKE × n=32/n=64, h=20, d=2; signs at idx=4 after 4 dummy signs; fingerprint comparison |

`test_xmss_mt_kat` fingerprints were generated by `third_party/xmss-reference/test/gen_mt_kat.c` using the reference's `xmssmt_core_seed_keypair` + `xmssmt_core_sign` (naive, non-BDS). The seed layout and signature byte format are identical between the reference and our implementation, so no translation layer is needed for signature comparison (only SK serialisation differs: the reference embeds BDS state in SK while we keep it separate).

Both KATs cover SHA-2/SHAKE × n=32/n=64 — the same axes — so parameter set coverage is symmetric across XMSS and XMSS-MT.
