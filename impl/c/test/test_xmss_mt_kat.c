/**
 * test_xmss_mt_kat.c - XMSS-MT Known Answer Tests cross-validated against xmss-reference
 *
 * For each XMSS-MT parameter set, we:
 *   1. Replay deterministic seeds (seed[i] = i for i = 0..3n-1)
 *   2. Keygen with BDS (xmss_mt_keygen)
 *   3. SHAKE128-fingerprint pk (without OID prefix) — validates tree root
 *   4. Sign 4 dummy messages to advance BDS state to idx=4
 *   5. Sign single-byte message {37} at idx=4
 *   6. SHAKE128-fingerprint sig — validates auth path at idx=4
 *   7. Verify the signature is valid
 *   8. Compare against fingerprints generated by xmss-reference (gen_mt_kat.c)
 *
 * Reference format notes:
 *   xmss-reference xmssmt_core_sign() is the naive (non-BDS) implementation.
 *   Given the same key material it produces byte-identical signatures to our
 *   BDS-accelerated xmss_mt_sign() because both compute the same deterministic
 *   function: given (SK_SEED, SK_PRF, PUB_SEED, idx, msg) → sig.
 *
 *   The reference does NOT embed BDS state in the SK for signature comparison;
 *   only its SK serialisation format differs.  Signature bytes are identical.
 *
 * Reference PK layout (core, no OID): root(n) | PUB_SEED(n)
 * Our PK layout:                      OID(4) | root(n) | PUB_SEED(n)
 *   → skip first 4 bytes of our PK to match reference footprint.
 *
 * Signature layouts are byte-identical (both RFC 8391 §4.2.4 format).
 */
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>

#include "test_utils.h"
#include "../include/xmss/params.h"
#include "../include/xmss/types.h"
#include "../include/xmss/xmss.h"
#include "../src/hash/shake_local.h"

/* KAT target: sign 4 dummies, then sign {37} at idx=4 */
#define KAT_TARGET_IDX 4

/* Replay-style randombytes: produces exact seed bytes from a buffer */
static uint8_t kat_seed_buf[3 * XMSS_MAX_N];
static size_t  kat_seed_off;

static int kat_randombytes(uint8_t *buf, size_t len)
{
    memcpy(buf, kat_seed_buf + kat_seed_off, len);
    kat_seed_off += len;
    return 0;
}

/*
 * Reference fingerprints generated by third_party/xmss-reference/test/gen_mt_kat.c.
 * Seed: seed[i]=i for i=0..3n-1.  Message {37} signed at idx=4 (after 4 dummy signs).
 * Fingerprint = SHAKE128(data, len) truncated to 10 bytes (hex).
 *
 * pk_hash:  SHAKE128(pk_without_oid, pk_bytes-4) → 10 bytes
 * sig_hash: SHAKE128(sig, sig_bytes)             → 10 bytes
 *
 * OIDs here are our internal OIDs (0x01xxxxxx prefix).
 */
typedef struct {
    uint32_t    oid;      /* our internal XMSS-MT OID */
    const char *name;
    const char *pk_hash;
    const char *sig_hash;
} kat_mt_vector_t;

static const kat_mt_vector_t mt_vectors[] = {
    /* Auto-generated by gen_mt_kat — do not edit by hand.
     * Fingerprint = SHAKE128(data, len) truncated to 10 bytes (hex).
     * Keygen seed: seed[i]=i for i=0..3n-1.
     * Message {37} signed at idx=4 (after 4 dummy signs).
     */
    { OID_XMSS_MT_SHA2_20_2_256,   "XMSSMT-SHA2_20/2_256",
      "bea144e05295be8f3242", "8cd2a3516ed88f5c186b" },
    { OID_XMSS_MT_SHA2_20_4_256,   "XMSSMT-SHA2_20/4_256",
      "9df4c75282451bf2bc53", "c8f43d9e01cf8e3800c3" },
    { OID_XMSS_MT_SHAKE_20_2_256,  "XMSSMT-SHAKE_20/2_256",
      "4865cb2e057f1870aa91", "48b624a556a41efd8be4" },
    { OID_XMSS_MT_SHAKE_20_4_256,  "XMSSMT-SHAKE_20/4_256",
      "dbe6fc388fbd610b3401", "6dcff4761bf4e9989f73" },
};

#define NUM_MT_VECTORS (sizeof(mt_vectors) / sizeof(mt_vectors[0]))

static void run_mt_kat(const kat_mt_vector_t *v)
{
    xmss_params p;
    xmss_mt_state *state;
    uint8_t *pk, *sk, *sig;
    uint8_t msg[1] = {37};
    uint8_t dummy[1] = {0};
    uint8_t fp[10], expected[10];
    char label[128];
    uint32_t i;

    if (xmss_mt_params_from_oid(&p, v->oid) != 0) {
        snprintf(label, sizeof(label), "%s: params", v->name);
        TEST(label, 0);
        return;
    }

    pk    = (uint8_t *)malloc(p.pk_bytes);
    sk    = (uint8_t *)malloc(p.sk_bytes);
    sig   = (uint8_t *)malloc(p.sig_bytes);
    state = (xmss_mt_state *)malloc(sizeof(xmss_mt_state));
    if (!pk || !sk || !sig || !state) {
        TEST("malloc", 0);
        free(pk); free(sk); free(sig); free(state);
        return;
    }

    /* Fill seed buffer: seed[i] = i for i = 0..3n-1 */
    for (i = 0; i < 3 * p.n; i++) {
        kat_seed_buf[i] = (uint8_t)i;
    }
    kat_seed_off = 0;

    /* Keygen with deterministic seeds (BDS) */
    if (xmss_mt_keygen(&p, pk, sk, state, 0, kat_randombytes) != XMSS_OK) {
        snprintf(label, sizeof(label), "%s: keygen", v->name);
        TEST(label, 0);
        goto done;
    }

    /* Verify PK fingerprint (skip 4-byte OID to match reference core layout) */
    shake128_local(fp, 10, pk + 4, p.pk_bytes - 4);
    hex_decode(expected, v->pk_hash, 10);
    snprintf(label, sizeof(label), "%s: pk fingerprint", v->name);
    if (memcmp(fp, expected, 10) != 0) {
        TEST(label, 0);
        hex_print("  expected", expected, 10);
        hex_print("  got     ", fp, 10);
    } else {
        TEST(label, 1);
    }

    /* Advance BDS state to idx=KAT_TARGET_IDX by signing dummy messages */
    for (i = 0; i < KAT_TARGET_IDX; i++) {
        if (xmss_mt_sign(&p, sig, dummy, 1, sk, state, 0) != XMSS_OK) {
            snprintf(label, sizeof(label), "%s: advance sign idx=%u", v->name, i);
            TEST(label, 0);
            goto done;
        }
    }

    /* Sign the KAT message at idx=KAT_TARGET_IDX */
    if (xmss_mt_sign(&p, sig, msg, 1, sk, state, 0) != XMSS_OK) {
        snprintf(label, sizeof(label), "%s: kat sign", v->name);
        TEST(label, 0);
        goto done;
    }

    /* Verify signature fingerprint */
    shake128_local(fp, 10, sig, p.sig_bytes);
    hex_decode(expected, v->sig_hash, 10);
    snprintf(label, sizeof(label), "%s: sig fingerprint", v->name);
    if (memcmp(fp, expected, 10) != 0) {
        TEST(label, 0);
        hex_print("  expected", expected, 10);
        hex_print("  got     ", fp, 10);
    } else {
        TEST(label, 1);
    }

    /* Also verify the signature is valid */
    {
        int rc = xmss_mt_verify(&p, msg, 1, sig, pk);
        snprintf(label, sizeof(label), "%s: verify own sig", v->name);
        TEST(label, rc == XMSS_OK);
    }

done:
    free(pk);
    free(sk);
    free(sig);
    free(state);
}

int main(void)
{
    size_t i;

    printf("=== test_xmss_mt_kat (cross-validated against xmss-reference) ===\n");
    printf("    Signing at idx=%d (after %d dummy signs)\n\n",
           KAT_TARGET_IDX, KAT_TARGET_IDX);

    for (i = 0; i < NUM_MT_VECTORS; i++) {
        printf("--- %s ---\n", mt_vectors[i].name);
        run_mt_kat(&mt_vectors[i]);
    }

    return tests_done();
}
