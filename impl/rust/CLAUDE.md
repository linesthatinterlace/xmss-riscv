# CLAUDE.md — xmss-jasmin Rust implementation

Context for Claude Code when working on the Rust implementation of XMSS/XMSS-MT. All paths below are relative to `impl/rust/`.

Status: **planned / in progress**.

## Build commands

```bash
cargo build                   # Debug build
cargo build --release         # Release build
cargo test                    # Run all tests
cargo test --release          # Run all tests (optimised)
cargo test -- --nocapture     # Tests with stdout visible
cargo test <name>             # Run a single test by name substring

# Check without building
cargo check
cargo clippy -- -D warnings
```

## Crate structure

Single library crate (`src/lib.rs`) with no binary target. The public API exposes only keygen/sign/verify for XMSS and XMSS-MT.

Planned module layout (one algorithm per file, mirroring the C implementation):

```
src/
  lib.rs           re-exports public API
  params.rs        parameter sets, OID table, XmssParams struct
  address.rs       XmssAdrs type and all setter functions
  utils.rs         ull_to_bytes, bytes_to_ull, ct_memcmp, xmss_memzero, PRF_idx
  hash/
    mod.rs         XmssHash trait (static dispatch interface)
    sha2.rs        SHA-256 / SHA-512 backends
    shake.rs       SHAKE-128 / SHAKE-256 backends
  wots.rs          WOTS+ sign, pkFromSig
  ltree.rs         L-tree hash
  treehash.rs      treehash and stack
  bds.rs           BDS state, bds_update, bds_treehash_update
  xmss.rs          XMSS keygen, sign, verify
  xmss_mt.rs       XMSS-MT keygen, sign, verify
```

## Architecture

### Hash abstraction boundary

The `XmssHash` trait (in `src/hash/mod.rs`) is the **sole** dispatch point for SHA-2 vs SHAKE. All algorithm code calls only the trait methods:

```rust
fn F(params: &XmssParams, key: &[u8], m: &[u8], out: &mut [u8]);
fn H(params: &XmssParams, key: &[u8], m: &[u8], out: &mut [u8]);
fn H_msg(params: &XmssParams, r: &[u8], root: &[u8], idx: &[u8], m: &[u8], out: &mut [u8]);
fn PRF(params: &XmssParams, key: &[u8], adrs: &[u8; 32], out: &mut [u8]);
fn PRF_keygen(params: &XmssParams, key: &[u8], adrs: &[u8; 32], out: &mut [u8]);
fn PRF_idx(params: &XmssParams, key: &[u8], idx_bytes: &[u8; 32], out: &mut [u8]);
```

Do not import hash backend types in any module other than `src/hash/`.

### No heap allocation

Algorithm code must not allocate on the heap. No `Vec`, `Box`, `HashMap`, `String`, or any other heap type in `src/`. All working buffers are fixed-size stack arrays dimensioned by `XMSS_MAX_*` constants. Caller-provided slices are used for large state (BDS state, MT state).

### Key constants (params.rs)

Mirroring the C implementation:

```rust
const XMSS_MAX_N: usize = 64;         // max hash output bytes
const XMSS_MAX_H: usize = 20;         // max per-tree height
const XMSS_MAX_FULL_H: usize = 60;    // max total tree height
const XMSS_MAX_D: usize = 12;         // max number of layers
const XMSS_MAX_WOTS_LEN: usize = 131; // max WOTS+ chain count
const XMSS_MAX_BDS_K: usize = 4;      // max BDS retain parameter
```

### ADRS structure

`XmssAdrs` is 8 x `u32` stored big-endian. Always manipulate via the setters in `src/address.rs`. `set_type()` must zero words 4–7 as required by RFC 8391 §2.5. Serialise to `[u8; 32]` on the stack before passing to hash functions.

### SK/PK layout (Errata 7900)

```
SK: OID(4) | idx(idx_bytes) | SK_SEED(n) | SK_PRF(n) | root(n) | SEED(n)
PK: OID(4) | root(n) | SEED(n)
XMSS Sig:    idx(idx_bytes) | r(n) | sig_WOTS(len*n) | auth(tree_height*n)
XMSS-MT Sig: idx(idx_bytes) | r(n) | d x [sig_WOTS(len*n) | auth(tree_height*n)]
```

Offset helpers are `#[inline]` functions in `src/sk_offsets.rs`, used by both `xmss.rs` and `xmss_mt.rs`.

### SHA-2 domain separation (RFC 8391 §5.1)

SHA-2 hash functions prepend `toByte(D, n)` (n−1 zero bytes then byte D):
- F = 0x00, H = 0x01, H_msg = 0x02, PRF = 0x03, PRF_keygen = 0x04

SHA-2 F and H also XOR inputs with bitmasks generated by PRF calls with `key_and_mask = 0, 1`. SHAKE does not use bitmasks.

## Rust-specific rules

These apply to all algorithm code and must not be broken:

| Rule | Requirement |
|------|-------------|
| R1 | No heap allocation. No `Vec`, `Box`, `String`, or `HashMap` in `src/`. All buffers are stack-allocated fixed-size arrays. |
| R2 | No dynamic dispatch in algorithm code. No `dyn Trait`. Hash dispatch uses generics (monomorphisation at the call site in `xmss.rs` / `xmss_mt.rs`). |
| R3 | No recursion. All tree algorithms are iterative with explicit stacks. |
| R4 | All array sizes use `XMSS_MAX_*` constants. No secret-length-dependent array indexing that leaks timing. |
| R5 | Secret-dependent branches and memory accesses must be constant-time. Use the `subtle` crate for CT comparisons. Annotate any deviations. |
| R6 | `XmssAdrs` passed by `&mut` to setters; serialised to `[u8; 32]` on the stack before hash calls. |
| R7 | One algorithm per `.rs` file (module). |
| R8 | `unsafe` is forbidden in algorithm code. If `unsafe` is ever required, isolate it in a dedicated module with an explicit `# Safety` justification. |

## Dependencies

Runtime:
- `sha2` — SHA-256 / SHA-512 (RustCrypto)
- `sha3` — SHAKE-128 / SHAKE-256 (RustCrypto)
- `subtle` — constant-time comparisons

Dev/test only:
- `hex-literal` or `hex` — for KAT vectors

No other dependencies. The crate must remain `no_std`-compatible in principle (std is allowed for tests, but algorithm code should not rely on `std`-only APIs).

## Test structure (planned)

Tests mirror the C test suite and live in `tests/` (integration tests) or `#[cfg(test)]` modules within each source file.

| Test | What it covers |
|------|---------------|
| `test_params` | All 12 XMSS OIDs and 32 XMSS-MT OIDs: n, w, h, d, len, sig_bytes, pk_bytes, sk_bytes, idx_bytes |
| `test_address` | ADRS serialisation, all setter types, set_type() zeroing |
| `test_hash` | SHA-256, SHA-512 (FIPS 180-4 vectors), SHAKE-128, SHAKE-256 (NIST vectors) |
| `test_wots` | sign → pkFromSig roundtrip (n=32 and n=64), wrong-message detection |
| `test_xmss` | BDS keygen/sign/verify roundtrip; bit-flip and wrong-message rejection; idx increment; sequential signing |
| `test_kat` | SHAKE128-fingerprint cross-validation against xmss-reference for h=10 parameter sets |
| `test_bds` | BDS-specific: bds_k validation; roundtrip and sequential signing with bds_k=2 and bds_k=4 |
| `test_xmss_mt` | XMSS-MT keygen/sign/verify roundtrip; bit-flip and wrong-message rejection; tree boundary crossing |

A deterministic test RNG (seeded, reproducible) should be provided in `tests/test_utils.rs`.

## Future work

- Serialisation/deserialisation of BDS state (for persisting signing state across process restarts)
- XMSS-MT KAT cross-validation
- Remaining-signatures query
- `no_std` crate feature (disable `std`, provide an allocator-free API)
- Benchmarks (`benches/`) via Criterion
