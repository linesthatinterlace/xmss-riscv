# CLAUDE.md — xmss-jasmin

Context for Claude Code when working on this repository.

## Build commands

A top-level `Makefile` wraps CMake for convenience:

```bash
make            # Release build
make test       # Build + run all tests (~2 min)
make test-fast  # Build + run only fast tests (CTest label "fast")
make debug      # Debug build (ASan + UBSan — very slow for crypto tests)
make rv         # RISC-V cross-compile
make clean      # Remove all build directories

# Run a single test binary directly
./build-rel/test/test_params
./build-rel/test/test_xmss   # BDS keygen/sign/verify roundtrip + sequential
./build-rel/test/test_kat    # KAT cross-validation (advances BDS to idx=512)
./build-rel/test/test_bds    # BDS-specific: bds_k validation, k=2/k=4 roundtrips

# RISC-V execution via QEMU
qemu-riscv64 -L /usr/riscv64-linux-gnu build-rv/test/test_params
qemu-riscv64 -L /usr/riscv64-linux-gnu build-rv/test/test_xmss
```

## Architecture

### Hash abstraction boundary

`src/hash/xmss_hash.c` is the **sole** file that dispatches to SHA-2 or SHAKE. All algorithm code (`wots.c`, `ltree.c`, `treehash.c`, `bds.c`, `xmss.c`, `xmssmt.c`) calls only:

```c
xmss_F(), xmss_H(), xmss_H_msg(), xmss_PRF(), xmss_PRF_keygen(), xmss_PRF_idx()
```

declared in `src/hash/hash_iface.h`. Do not add hash backend includes to any other file.

### No malloc

The entire library is allocation-free. All buffers are either stack-local or caller-provided. The largest allocations are:
- `xmssmt_state`: ~780 KB (caller-managed; holds 2×MAX_D-1 BDS states + WOTS sig cache)
- `xmss_bds_state`: ~34 KB (caller-managed; see `include/xmss/xmss.h`)
- `wots_buf_t`: `XMSS_MAX_WOTS_LEN * XMSS_MAX_N` = 131 × 64 = 8384 bytes (in `wots.c`)
- `treehash_stack_t`: `(XMSS_MAX_H+1) * XMSS_MAX_N` = 21 × 64 = 1344 bytes (in `treehash.c`)

### Key constants (params.h)

```c
XMSS_MAX_N        64   // max hash output bytes (n)
XMSS_MAX_H        20   // max per-tree height (BDS arrays sized by this)
XMSS_MAX_FULL_H   60   // max total tree height across all layers
XMSS_MAX_D        12   // max number of layers (XMSSMT-*_60/12_*)
XMSS_MAX_WOTS_LEN 131  // max WOTS+ chain count (len1+len2 for n=64, w=16)
XMSS_MAX_BDS_K    4    // max BDS retain parameter (must be even, ≤ tree_height)
```

These must be kept consistent with the OID table in `src/params.c`. If new parameter sets are added, recalculate and update accordingly.

### ADRS (address) structure

`xmss_adrs_t` is 8 × `uint32_t` stored big-endian. Always manipulate via the setters in `src/address.h`. **Never** write to `a.w[]` directly in algorithm code.

`xmss_adrs_set_type()` zeros words 4–7 as required by RFC 8391 §2.5. This differs from xmss-reference which does not do this.

### SK/PK layout (Errata 7900)

```
SK: OID(4) | idx(idx_bytes) | SK_SEED(n) | SK_PRF(n) | root(n) | SEED(n)
PK: OID(4) | root(n) | SEED(n)
XMSS Sig:    idx(idx_bytes) | r(n) | sig_WOTS(len*n) | auth(tree_height*n)
XMSS-MT Sig: idx(idx_bytes) | r(n) | d × [sig_WOTS(len*n) | auth(tree_height*n)]
```

SK/PK layout is the same for XMSS and XMSS-MT (only idx_bytes differs).
Offset helpers are shared `static inline` functions in `src/sk_offsets.h`, included by both `xmss.c` and `xmssmt.c`.

### SHA-2 domain separation (RFC 8391 §5.1)

The SHA-2 hash functions prepend `toByte(D, n)` (n−1 zero bytes then byte D):
- F = 0x00, H = 0x01, H_msg = 0x02, PRF = 0x03, PRF_keygen = 0x04

SHA-2 F and H also XOR inputs with bitmasks generated by PRF calls with `key_and_mask=0,1`. SHAKE does not use bitmasks.

### `xmss_PRF_idx`

A special variant of PRF used only in `xmss_sign` to compute `r = PRF(SK_PRF, toByte(idx, 32))`. The 32-byte input is a raw index encoding, not an ADRS structure. Declared in `hash_iface.h`, implemented in `xmss_hash.c`.

## Jasmin portability rules

These are enforced and must not be broken by any change:

| Rule | What to check |
|------|---------------|
| J1 | No VLAs — use `XMSS_MAX_*` constants. `-Wvla` will catch violations at compile time. |
| J2 | No function pointers in algorithm code. Dispatch lives only in `xmss_hash.c`. |
| J3 | No `malloc`/`calloc`/`free` anywhere in `src/`. |
| J4 | No recursive functions. All tree algorithms are iterative with explicit stacks. |
| J5 | All loop bounds must be compile-time constants or `params->*` fields. |
| J6 | Secret-dependent branches and memory accesses must be constant-time. Verification uses `ct_memcmp`. Annotate deviations. |
| J7 | ADRS passed by pointer to setters; serialised to `uint8_t[32]` on the stack before passing to hash functions. |
| J8 | One algorithm per `.c` file. |

## Test structure

| Binary | What it tests |
|--------|--------------|
| `test_params` | All 12 XMSS OIDs: n, w, h, len, sig_bytes, pk_bytes, sk_bytes, idx_bytes |
| `test_address` | ADRS serialisation, all setter types, set_type() zeroing |
| `test_hash` | SHA-256, SHA-512 (FIPS 180-4 vectors), SHAKE-128, SHAKE-256 (NIST vectors), incremental API |
| `test_wots` | sign→pkFromSig roundtrip (n=32 and n=64), wrong message detection |
| `test_xmss` | BDS keygen/sign/verify roundtrip (3 param sets); bit-flip and wrong-message rejection; idx increment; sequential signing (20 sigs) |
| `test_kat` | SHAKE128-fingerprint cross-validation against xmss-reference for 4 h=10 parameter sets (advances BDS to idx=512 for sig fingerprint) |
| `test_bds` | BDS-specific: bds_k validation (odd/too-large rejected); roundtrip and sequential signing with bds_k=2 and bds_k=4 |
| `test_bds_serial` | BDS serialization: round-trip after keygen, mid-signing, byte-exact, size consistency, multiple param sets, bds_k=2 |
| `test_xmssmt_params` | All 32 XMSS-MT OIDs: n, w, h, d, tree_height, len, sig_bytes, pk_bytes, sk_bytes, idx_bytes; RFC and internal OID lookup |
| `test_xmssmt` | XMSS-MT keygen/sign/verify roundtrip; bit-flip and wrong-message rejection; sequential signing (5 sigs); tree boundary crossing (1024+ sigs) |
| `test_utils_internal` | ct_memcmp, ull_to_bytes, bytes_to_ull, xmss_memzero, xmss_PRF_idx, key exhaustion |

`test_utils.h` provides a deterministic RNG (`test_randombytes`) seeded with `test_rng_reset()` for reproducible test runs.

## Future work

- **Remaining-signatures query**: `xmss_sign`/`xmssmt_sign` return `XMSS_ERR_EXHAUSTED` when the index is spent, but there is no function to query how many signatures remain.
- **XMSS-MT KAT**: Cross-validation against xmss-reference for XMSS-MT parameter sets (the reference embeds BDS state in the SK buffer, so byte-level comparison requires a translation layer).

## Dependencies

None at runtime. Build requires CMake ≥ 3.16 and a C99 compiler. `third_party/` contains:
- `xmss-reference/` — git submodule of [XMSS/xmss-reference](https://github.com/XMSS/xmss-reference). **Read-only reference**: used to regenerate KAT fingerprints and as an algorithmic reference (especially for BDS in `xmss_core_fast.c`). **Do NOT copy code from it** — our implementation must follow Jasmin portability rules (no VLAs, no malloc, no function pointers, etc.) which the reference violates. Only read it to understand algorithm logic, then reimplement from scratch.
