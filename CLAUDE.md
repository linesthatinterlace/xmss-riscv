# CLAUDE.md — xmss-riscv

Context for Claude Code when working on this repository.

## Build commands

```bash
# Native debug build (with ASan + UBSan)
cmake -B build -DCMAKE_BUILD_TYPE=Debug
cmake --build build

# Run tests
ctest --test-dir build --output-on-failure

# Run a single test binary directly
./build/test/test_params
./build/test/test_hash
./build/test/test_wots
./build/test/test_xmss   # slow: full tree traversal (~250s native, ~4min RISC-V)

# RISC-V cross-compile
cmake -B build-rv -DCMAKE_TOOLCHAIN_FILE=cmake/toolchain-riscv64.cmake -DCMAKE_BUILD_TYPE=Release
cmake --build build-rv

# RISC-V execution via QEMU
qemu-riscv64 -L /usr/riscv64-linux-gnu build-rv/test/test_params
qemu-riscv64 -L /usr/riscv64-linux-gnu build-rv/test/test_xmss
```

## Architecture

### Hash abstraction boundary

`src/hash/xmss_hash.c` is the **sole** file that dispatches to SHA-2 or SHAKE. All algorithm code (`wots.c`, `ltree.c`, `treehash.c`, `xmss.c`) calls only:

```c
xmss_F(), xmss_H(), xmss_H_msg(), xmss_PRF(), xmss_PRF_keygen(), xmss_PRF_idx()
```

declared in `src/hash/hash_iface.h`. Do not add hash backend includes to any other file.

### No malloc

The entire library is allocation-free. All buffers are either stack-local or caller-provided. The largest stack allocations are:
- `wots_buf_t`: `XMSS_MAX_WOTS_LEN * XMSS_MAX_N` = 131 × 64 = 8384 bytes (in `wots.c`)
- `treehash_stack_t`: `(XMSS_MAX_H+1) * XMSS_MAX_N` = 21 × 64 = 1344 bytes (in `treehash.c`)

### Key constants (params.h)

```c
XMSS_MAX_N        64   // max hash output bytes (n)
XMSS_MAX_H        20   // max tree height (h)
XMSS_MAX_WOTS_LEN 131  // max WOTS+ chain count (len1+len2 for n=64, w=16)
```

These must be kept consistent with the OID table in `src/params.c`. If new parameter sets are added, recalculate and update accordingly.

### ADRS (address) structure

`xmss_adrs_t` is 8 × `uint32_t` stored big-endian. Always manipulate via the setters in `src/address.h`. **Never** write to `a.w[]` directly in algorithm code.

`xmss_adrs_set_type()` zeros words 4–7 as required by RFC 8391 §2.7.3. This differs from xmss-reference which does not do this.

### SK/PK layout (Errata 7900)

```
SK: OID(4) | idx(idx_bytes) | SK_SEED(n) | SK_PRF(n) | root(n) | SEED(n)
PK: OID(4) | root(n) | SEED(n)
Sig: idx(idx_bytes) | r(n) | sig_WOTS(len*n) | auth(h*n)
```

Offset helpers are static functions at the top of `src/xmss.c`. Use them, do not hardcode offsets.

### SHA-2 domain separation (RFC 8391 §5.1)

The SHA-2 hash functions prepend `toByte(D, n)` (n−1 zero bytes then byte D):
- F = 0x00, H = 0x01, H_msg = 0x02, PRF = 0x03, PRF_keygen = 0x04

SHA-2 F and H also XOR inputs with bitmasks generated by PRF calls with `key_and_mask=0,1`. SHAKE does not use bitmasks.

### `xmss_PRF_idx`

A special variant of PRF used only in `xmss_sign` to compute `r = PRF(SK_PRF, toByte(idx, 32))`. The 32-byte input is a raw index encoding, not an ADRS structure. Declared in `hash_iface.h`, implemented in `xmss_hash.c`.

## Jasmin portability rules

These are enforced and must not be broken by any change:

| Rule | What to check |
|------|---------------|
| J1 | No VLAs — use `XMSS_MAX_*` constants. `-Wvla` will catch violations at compile time. |
| J2 | No function pointers in algorithm code. Dispatch lives only in `xmss_hash.c`. |
| J3 | No `malloc`/`calloc`/`free` anywhere in `src/`. |
| J4 | No recursive functions. All tree algorithms are iterative with explicit stacks. |
| J5 | All loop bounds must be compile-time constants or `params->*` fields. |
| J6 | Secret-dependent branches and memory accesses must be constant-time. Verification uses `ct_memcmp`. Annotate deviations. |
| J7 | ADRS passed by pointer to setters; serialised to `uint8_t[32]` on the stack before passing to hash functions. |
| J8 | One algorithm per `.c` file. |

## Test structure

| Binary | What it tests |
|--------|--------------|
| `test_params` | All 12 OIDs: n, w, h, len, sig_bytes, pk_bytes, sk_bytes, idx_bytes |
| `test_address` | ADRS serialisation, all setter types, set_type() zeroing |
| `test_hash` | SHA-256, SHA-512 (FIPS 180-4 vectors), SHAKE-128, SHAKE-256 (NIST vectors), incremental API |
| `test_wots` | sign→pkFromSig roundtrip (n=32 and n=64), wrong message detection |
| `test_xmss` | keygen/sign/verify roundtrip; bit-flip and wrong-message rejection; idx increment |

`test_utils.h` provides a deterministic RNG (`test_randombytes`) seeded with `test_rng_reset()` for reproducible test runs.

## Known limitations / future work

- **Auth path**: naive O(h·2^h) — recomputes the full sibling subtree for each auth path node. Phase 7 (BDS algorithm) will replace this.
- **XMSS-MT**: deferred. The layer/tree address fields and `d` parameter are already in `xmss_params` and `xmss_adrs_t`.
- **RFC KAT vectors**: Phase 6 (file-driven KAT against RFC 8391 Appendix D) is not yet implemented.
- **xmss_sign exhaustion**: returns `XMSS_ERR_EXHAUSTED` when `idx > idx_max`, but there is no separate "remaining uses" query function yet.

## Dependencies

None at runtime. Build requires CMake ≥ 3.16 and a C99 compiler. `third_party/` (PQClean SHA-2 and fips202) is vendored for reference but **not used** in the build — the library uses its own stack-based implementations in `src/hash/sha2_local.c` and `src/hash/shake_local.c`.

## Comments
Some comments for reviewing models:

- SHA-2 domain separation in xmss_hash.c — the bitmask XOR construction for F and H is the most complex and RFC-sensitive part. Worth scrutinising carefully against RFC 8391 §5.1.
- xmss_PRF_idx — this is a slight departure from the ADRS-based PRF interface (it takes a raw uint64_t index). The review should confirm it matches the RFC's PRF(SK_PRF, toByte(idx, 32)) exactly. (User comment: probably need to fix
this and make it match the spec...)
- Naive auth path — treehash_auth_path() is known-slow (O(h·2^h)) and isn't subtle code, but the indexing logic for sibling nodes is worth a second look. (User note: is this acceptably slow? Is this avoidable?)
- test_xmss.c uses malloc — the integration test allocates pk/sk/sig on the heap for convenience, which is fine for test code but worth noting is not representative of the library itself.