# CLAUDE.md — xmss-riscv

Context for Claude Code when working on this repository.

## Build commands

```bash
# Native debug build (with ASan + UBSan)
cmake -B build -DCMAKE_BUILD_TYPE=Debug
cmake --build build

# Run all tests (Release build recommended — Debug/ASan is very slow for crypto)
cmake -B build-rel -DCMAKE_BUILD_TYPE=Release && cmake --build build-rel
ctest --test-dir build-rel --output-on-failure

# Run a single test binary directly
./build-rel/test/test_params
./build-rel/test/test_hash
./build-rel/test/test_wots
./build-rel/test/test_xmss   # BDS keygen/sign/verify roundtrip + sequential
./build-rel/test/test_kat    # KAT cross-validation (advances BDS to idx=512)
./build-rel/test/test_bds    # BDS-specific: bds_k validation, k=2/k=4 roundtrips

# RISC-V cross-compile
cmake -B build-rv -DCMAKE_TOOLCHAIN_FILE=cmake/toolchain-riscv64.cmake -DCMAKE_BUILD_TYPE=Release
cmake --build build-rv

# RISC-V execution via QEMU
qemu-riscv64 -L /usr/riscv64-linux-gnu build-rv/test/test_params
qemu-riscv64 -L /usr/riscv64-linux-gnu build-rv/test/test_xmss
```

## Architecture

### Hash abstraction boundary

`src/hash/xmss_hash.c` is the **sole** file that dispatches to SHA-2 or SHAKE. All algorithm code (`wots.c`, `ltree.c`, `treehash.c`, `bds.c`, `xmss.c`) calls only:

```c
xmss_F(), xmss_H(), xmss_H_msg(), xmss_PRF(), xmss_PRF_keygen(), xmss_PRF_idx()
```

declared in `src/hash/hash_iface.h`. Do not add hash backend includes to any other file.

### No malloc

The entire library is allocation-free. All buffers are either stack-local or caller-provided. The largest allocations are:
- `xmss_bds_state`: ~34 KB (caller-managed; see `include/xmss/xmss.h`)
- `wots_buf_t`: `XMSS_MAX_WOTS_LEN * XMSS_MAX_N` = 131 × 64 = 8384 bytes (in `wots.c`)
- `treehash_stack_t`: `(XMSS_MAX_H+1) * XMSS_MAX_N` = 21 × 64 = 1344 bytes (in `treehash.c`)

### Key constants (params.h)

```c
XMSS_MAX_N        64   // max hash output bytes (n)
XMSS_MAX_H        20   // max tree height (h)
XMSS_MAX_WOTS_LEN 131  // max WOTS+ chain count (len1+len2 for n=64, w=16)
XMSS_MAX_BDS_K    4    // max BDS retain parameter (must be even, ≤ h)
```

These must be kept consistent with the OID table in `src/params.c`. If new parameter sets are added, recalculate and update accordingly.

### ADRS (address) structure

`xmss_adrs_t` is 8 × `uint32_t` stored big-endian. Always manipulate via the setters in `src/address.h`. **Never** write to `a.w[]` directly in algorithm code.

`xmss_adrs_set_type()` zeros words 4–7 as required by RFC 8391 §2.5. This differs from xmss-reference which does not do this.

### SK/PK layout (Errata 7900)

```
SK: OID(4) | idx(idx_bytes) | SK_SEED(n) | SK_PRF(n) | root(n) | SEED(n)
PK: OID(4) | root(n) | SEED(n)
Sig: idx(idx_bytes) | r(n) | sig_WOTS(len*n) | auth(h*n)
```

Offset helpers are static functions at the top of `src/xmss.c`. Use them, do not hardcode offsets.

### SHA-2 domain separation (RFC 8391 §5.1)

The SHA-2 hash functions prepend `toByte(D, n)` (n−1 zero bytes then byte D):
- F = 0x00, H = 0x01, H_msg = 0x02, PRF = 0x03, PRF_keygen = 0x04

SHA-2 F and H also XOR inputs with bitmasks generated by PRF calls with `key_and_mask=0,1`. SHAKE does not use bitmasks.

### `xmss_PRF_idx`

A special variant of PRF used only in `xmss_sign` to compute `r = PRF(SK_PRF, toByte(idx, 32))`. The 32-byte input is a raw index encoding, not an ADRS structure. Declared in `hash_iface.h`, implemented in `xmss_hash.c`.

## Jasmin portability rules

These are enforced and must not be broken by any change:

| Rule | What to check |
|------|---------------|
| J1 | No VLAs — use `XMSS_MAX_*` constants. `-Wvla` will catch violations at compile time. |
| J2 | No function pointers in algorithm code. Dispatch lives only in `xmss_hash.c`. |
| J3 | No `malloc`/`calloc`/`free` anywhere in `src/`. |
| J4 | No recursive functions. All tree algorithms are iterative with explicit stacks. |
| J5 | All loop bounds must be compile-time constants or `params->*` fields. |
| J6 | Secret-dependent branches and memory accesses must be constant-time. Verification uses `ct_memcmp`. Annotate deviations. |
| J7 | ADRS passed by pointer to setters; serialised to `uint8_t[32]` on the stack before passing to hash functions. |
| J8 | One algorithm per `.c` file. |

## Test structure

| Binary | What it tests |
|--------|--------------|
| `test_params` | All 12 OIDs: n, w, h, len, sig_bytes, pk_bytes, sk_bytes, idx_bytes |
| `test_address` | ADRS serialisation, all setter types, set_type() zeroing |
| `test_hash` | SHA-256, SHA-512 (FIPS 180-4 vectors), SHAKE-128, SHAKE-256 (NIST vectors), incremental API |
| `test_wots` | sign→pkFromSig roundtrip (n=32 and n=64), wrong message detection |
| `test_xmss` | BDS keygen/sign/verify roundtrip (3 param sets); bit-flip and wrong-message rejection; idx increment; sequential signing (20 sigs) |
| `test_kat` | SHAKE128-fingerprint cross-validation against xmss-reference for 4 h=10 parameter sets (advances BDS to idx=512 for sig fingerprint) |
| `test_bds` | BDS-specific: bds_k validation (odd/too-large rejected); roundtrip and sequential signing with bds_k=2 and bds_k=4 |

`test_utils.h` provides a deterministic RNG (`test_randombytes`) seeded with `test_rng_reset()` for reproducible test runs.

## Known limitations / future work

- **Auth path**: Two implementations available:
  - **Naive** (`xmss_sign`): O(h·2^h) per signature — recomputes the full sibling subtree. Impractical for h≥16.
  - **BDS** (`xmss_sign_bds`): O(h/2) leaf computations per signature. Requires a caller-managed `xmss_bds_state` initialised by `xmss_keygen_bds()`. SK stays RFC-compatible; BDS state is separate.
  - BDS `bds_k` parameter (0, 2, or 4): trades retain storage for fewer treehash updates. Default 0 is simplest.
- **XMSS-MT**: deferred. The layer/tree address fields and `d` parameter are already in `xmss_params` and `xmss_adrs_t`.
- **xmss_sign exhaustion**: returns `XMSS_ERR_EXHAUSTED` when `idx > idx_max`, but there is no separate "remaining uses" query function yet.

## Dependencies

None at runtime. Build requires CMake ≥ 3.16 and a C99 compiler. `third_party/` contents:
- `sha2/`, `fips202/` — PQClean vendored sources, not used in the build (we use `src/hash/sha2_local.c` and `src/hash/shake_local.c`).
- `xmss-reference/` — git submodule of [XMSS/xmss-reference](https://github.com/XMSS/xmss-reference). **Read-only reference**: used to regenerate KAT fingerprints and as an algorithmic reference (especially for BDS in `xmss_core_fast.c`). **Do NOT copy code from it** — our implementation must follow Jasmin portability rules (no VLAs, no malloc, no function pointers, etc.) which the reference violates. Only read it to understand algorithm logic, then reimplement from scratch.

## Comments
Some comments for reviewing models:

- Claude Sonnet 4.5 comment: SHA-2 domain separation in xmss_hash.c — the bitmask XOR construction for F and H is the most complex and RFC-sensitive part. Worth scrutinising carefully against RFC 8391 §5.1.
- Claude Sonnet 4.5 comment: xmss_PRF_idx — this is a slight departure from the ADRS-based PRF interface (it takes a raw uint64_t index). The review should confirm it matches the RFC's PRF(SK_PRF, toByte(idx, 32)) exactly. (User comment: probably need to fix
this and make it match the spec...)
- Claude Sonnet 4.5 comment: Naive auth path — treehash_auth_path() is known-slow (O(h·2^h)). (Resolved: BDS implementation in src/bds.c replaces it for practical use.)
- Claude Sonnet 4.5 comment: test_xmss.c uses malloc — the integration test allocates pk/sk/sig on the heap for convenience, which is fine for test code but worth noting is not representative of the library itself.
